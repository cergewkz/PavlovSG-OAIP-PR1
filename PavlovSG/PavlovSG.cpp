// Павлов Сергей Германович, группа ЦПИбв-21
// Язык выполнения работы: С++.

// Требования к сдаче лабораторных работ :
// 1. Исходный код отформатирован в едином стиле.
// 2. Исходный код лабораторной разбит на классы и методы.
// 3. Работоспособность лабораторной работы была протестирована на различных наборах входных данных.

// Задача: 
// * Реализовать АТД на структуре данных заданной по варианту, для объектов из предметной области.
// * Реализовать 2 сортировки по варианту 

// Вариант номер 1.
// Предметная область: книги в библиотеке
// Задание 1. АТД – Стек, СД – Массив.
// Задание 2. Сортировка вставками.
// Задание 3. Быстрая сортировка

// Задание 1.
// АТД – Стек, СД – Массив.
// Предметная область: книги в библиотеке

// Стек книг в библиотеке
// Стек – это структура данных, которая работает по принципу LIFO (Last In First Out),
// т.е. последний элемент, добавленный в стек, будет первым, который можно извлечь из стека.
// 
// Стек книг в библиотеке – это структура данных, которая хранит информацию о книгах в библиотеке. Каждая книга характеризуется следующими полями:
// название книги, автор, год издания, количество страниц.
// Стек должен поддерживать следующие операции:
// * добавление книги в стек
// * извлечение книги из стека

// Использую printf, т.к. C++ стандарный std::cout меня пугает. 
// Также установлена английская версия Windows, и возникла проблема с кодировкой, поэтому принудительно заменил на UTF8.

#include <cstdio>
#include <cstring>
#include <locale>
#include <windows.h>
#pragma execution_character_set( "utf-8" )

#define MAX_SIZE 255

// Структура для хранения информации о книге
struct Book {
    char title[MAX_SIZE];   // Название книги
    char author[MAX_SIZE];  // Автор книги
    int year;         // Год издания
    int pages;        // Количество страниц
};

// Класс, реализующий стек книг с использованием массива
class BookStack {
private:
    Book stack[MAX_SIZE];  // Массив для хранения книг в стеке
    int top;               // Индекс верхнего элемента стека

public:
    // Конструктор: инициализирует стек пустым
    BookStack() : top(-1) {}

    // Проверка, полон ли стек
    bool isFull() const {
        return top == MAX_SIZE - 1;
    }

    // Проверка, пуст ли стек
    bool isEmpty() const {
        return top == -1;
    }

    // Добавление книги в стек
    void push(const Book& book) {
        if (isFull()) {
            printf("\nСтек переполнен, невозможно добавить книгу.\n");
        }
        else {
            stack[++top] = book;  // Увеличиваем индекс и добавляем книгу
            printf("\nКнига добавлена: %s\n", book.title);
        }
    }

    // Извлечение книги из стека
    void pop() {
        if (isEmpty()) {
            printf("\nСтек пуст, невозможно извлечь книгу.\n");
        }
        else {
            Book book = stack[top--];  // Извлекаем книгу и уменьшаем индекс
            printf("\nКнига извлечена: %s\n", book.title);
        }
    }

    // Получение текущего количества книг в стеке
    int getSize() const {
        return top + 1;
    }

    // Получение массива книг (для сортировки и вывода)
    Book* getBooks() {
        return stack;
    }
};

// Сортировка вставками массива книг по названию
void insertionSort(Book books[], int size) {
    for (int i = 1; i < size; i++) {
        Book key = books[i];
        int j = i - 1;
        // Сравниваем книги и перемещаем их, если необходимо
        while (j >= 0 && strcmp(books[j].title, key.title) > 0) {
            books[j + 1] = books[j];
            j--;
        }
        books[j + 1] = key;  // Вставляем книгу на правильное место
    }
}

// Функция для разделения массива для быстрой сортировки
int partition(Book books[], int low, int high) {
    Book pivot = books[high];  // Опорный элемент (последний элемент массива)
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        // Если текущий элемент меньше опорного, меняем их местами
        if (strcmp(books[j].title, pivot.title) < 0) {
            i++;
            Book temp = books[i];
            books[i] = books[j];
            books[j] = temp;
        }
    }
    // Меняем опорный элемент с элементом на правильной позиции
    Book temp = books[i + 1];
    books[i + 1] = books[high];
    books[high] = temp;
    return (i + 1);
}

// Быстрая сортировка массива книг по названию
void quickSort(Book books[], int low, int high) {
    if (low < high) {
        // Разделяем массив на две части и рекурсивно сортируем
        int pi = partition(books, low, high);
        quickSort(books, low, pi - 1);
        quickSort(books, pi + 1, high);
    }
}

// Вывод информации о книгах
void printBooks(Book books[], int size) {
    for (int i = 0; i < size; i++) {
        printf("Название: %s, Автор: %s, Год: %d, Страниц: %d\n",
            books[i].title, books[i].author, books[i].year, books[i].pages);
    }
}

int main() {
    SetConsoleOutputCP(CP_UTF8);
    BookStack library;

    // Добавление книг в библиотеку
    Book book1 = { "Язык программирования C++", "Бьярне Страуструп", 1985, 328 };
    Book book2 = { "Война и мир", "Лев Толстой", 1869, 1225 };
    Book book3 = { "Преступление и наказание", "Федор Достоевский", 1866, 671 };
    Book book4 = { "Мастер и Маргарита", "Михаил Булгаков", 1967, 470 };
    Book book5 = { "Бегство Земли", "Франсис Карсак", 1943, 96 };

    library.push(book1);
    library.push(book2);
    library.push(book3);
    library.push(book4);
    library.push(book5);

    // Вывод текущего состояния стека (до извлечения из стека)
    printf("\nКниги в стеке до извлечения:\n");
    printBooks(library.getBooks(), library.getSize());

    // Извлечение книг из стека
    library.pop();
    library.pop();

    // Вывод текущего состояния стека (после извлечения из стека)
    printf("\nКниги в стеке после извлечения двух книг:\n");
    printBooks(library.getBooks(), library.getSize());



    // Стек проверили, переходим к сортировкам
    printf("\nТеперь выполняем / проверяем сортировки.\n");

    // Сортировка книг вставками и вывод результата
    insertionSort(library.getBooks(), library.getSize());
    printf("\nКниги в стеке после сортировки вставками:\n");
    printBooks(library.getBooks(), library.getSize());

    // Добавляем ещё несколько книг, чтобы проверить быструю сортировку
	Book book6 = { "Маленький принц", "Антуан де Сент-Экзюпери", 1943, 96 };
	Book book7 = { "Гарри Поттер и философский камень", "Джоан Роулинг", 1997, 223 };
	// Ну и одну на А, чтобы более наглядно было более наглядно видно, что сортировка отработала
	Book book8 = { "Анна Каренина", "Лев Толстой", 1877, 864 };

    library.push(book6);
    library.push(book7);
    library.push(book8);

    // Выводим сообщение о добавлении книг пользователю
    printf("\nДобавили ещё несколько книг в стек перед быстрой сортировкой (QuickSort).\n");
    printBooks(library.getBooks(), library.getSize());

    // Быстрая сортировка книг и вывод результата
    printf("\nКниги в стеке после QuickSort:\n");
    quickSort(library.getBooks(), 0, library.getSize() - 1);
    printBooks(library.getBooks(), library.getSize());

    return 0;
}